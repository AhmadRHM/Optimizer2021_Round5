<p align="center">
  <a href="" rel="noopener">
 <img src="http://optimizer.math.sharif.edu/wp-content/uploads/2021/02/optimizer.png" alt="Optimizer logo"></a>
</p>
<h3 align="center">عقاب‌های خسته‌بال</h3>

---

<div dir = "rtl">
<p align="center"> در این دور هدف پیدا کردن ماتریس V بود به طوری که هر درایه‌ی آن در بازه‌ی داده‌شده قرار داشته باشد، حداکثر K ستون از ماتریس SV درایه ناصفر داشته باشد و V بیشترین تعداد سطر صفر ممکن را داشته باشد. 
  برای حل این سوال، ابتدا مانند دور قبل، به ستون‌های V به صورت بردارهای مجزا نگاه کرده و برای هر یک از ستون‌های آن، با استفاده از روش‌های دور دوم، یک بردار پیدا کردیم که درایه‌های آن در بازه‌های داده‌شده صدق کنند، Sv=0 شود و همچنین v تعداد زیادی درایه صفر داشته باشد (در اینجا منظور از v ستون مورد نظر از V است). برای این کار همانطور که در دور دوم گفته شد ابتدا سعی شد به جای نرم l0 از نرم l1 استفاده شود و سپس به صورت گام به گام نتیجه بهبود داده شود. از آنجا که ابعاد مساله در این دور خصوصا در ورودی‌های دوم و سوم بسیار بزرگ بود، حل مساله دقیق با استفاده از MILP آنطور که در دور دوم توضیح داده شد بسیار زمان‌گیر بود. به همین دلیل در این دور و برای پیدا کردن ستون‌های V از MILP استفاده نکردیم و به همان بهبود نتایج با استفاده از روش گام به گام توضیح‌داده‌شده بسنده کردیم.  
  سپس با استفاده از یک مساله MILP حداکثر K ستون از ستون‌های V را ۰ کردیم (یعنی درایه‌هایی از آن ستون که ۰ جزو بازه‌ی شدنی آن‌ها بود را برابر ۰ قرار دادیم) به طوری که حداکثر تعداد سطرهای ممکن از V با این کار ۰ شوند.  
  در نهایت، با استفاده از یک MILP مشابه دور قبل، تعدادی از سطرهای V را ۰ کردیم تا به یک جواب خوب برسیم.
    <br> 
</p>
 </div>

## 📝 فهرست مطالب
- [صورت‌بندی سوال](#problem_statement)
- [الگوریتم بهینه‌سازی](#idea)
- [محدودیت‌ها](#limitations)
- [ایده‌های گسترش](#future_scope)
- [روند اجرا](#getting_started)
<!--- - [نحوه استفاده](#usage) --->
- [وابستگی‌ها](#tech_stack)
- [نویسندگان](#authors)
<!--- - [قدردانی](#acknowledgments) --->

## 🧐 صورت‌بندی سوال <a name = "problem_statement"></a>
![main_problem](https://github.com/AhmadRHM/Optimizer2021_Round5/blob/main/images/main_problem.png)

## 💡 الگوریتم بهینه‌سازی <a name = "idea"></a>
<div dir = "rtl">
  همانطور که در بالا گفته شد، ابتدا از روش‌های دور دوم استفاده کردیم و V را به صورت ستون به ستون به گونه‌ای ساختیم که در شرایط داده‌شده صدق کند، SV=0 باشد و با این کار تعداد زیادی از سطرهای V برابر ۰ می‌شوند. برای ورودی‌های دوم و سوم، مساله‌های MILP که در ادامه معرفی می‌شوند به دلیل ابعاد بزرگ مساله به جواب نرسیدند و به همین دلیل برای آن‌ها همین خروجی را فرستادیم. اما به هر حال روش‌های زیر پیاده‌سازی شده‌اند و حداقل به لحاظ تئوری باید جواب را بهبود بخشند.  
  بعد از به‌دست آمدن V اولیه از مرحله قبل، می‌خواهیم حداکثر K ستون از آن را برابر ۰ قرار دهیم، یعنی برای K تا از ستون‌های آن، درایه‌هایی که ۰ در بازه‌ی شدنی آن‌ّها قرار دارد را برابر ۰ قرار دهیم. درواقع با این کار داریم حداکثر K تا از ستون‌های SV را ناصفر می‌کنیم اما در ازای آن می‌خواهیم تعدادی از سطرهای V ۰ شوند. برای پیدا کردن این ستون‌ها، از یک MILP استفاده کردیم. ابتدا در V آن سطرهایی که در حال حاضر ۰ هستند و یا امکان ندارد ۰ شوند را حذف کردیم چرا که با ۰ کردن ستون‌های V تغییری در این سطرها نمی‌توانیم به وجود آوریم. با این کار تعداد زیادی از سطرهای V حذف می‌شود. سپس در ماتریس V باقی‌مانده، مساله MILP زیر را حل کردیم:  
  
![l1_problem](https://github.com/AhmadRHM/Optimizer2021_Round5/blob/main/images/cols_MILP.png)  
  دقت کنید در مساله بالا V همان ماتریسی است که تعداد زیادی از سطرهای آن را حذف کرده‌ایم و یک متغیر نیست. در مساله بالا، x_j برابر ۱ است اگر و تنها اگر بخواهیم ستون jام V را ۰ کنیم. همانطور که می‌توانید در قیدهای مساله فوق ببینید، می‌خواهیم تعداد این‌گونه سطرها حداکثر K باشد و هدف کمینه کردن مجموع درایه‌های
  v<sup>norm</sup>
و در نتیجه بیشینه کردن تعداد سطرهای تمام صفر V است.  
  بعد از حل مساله بالا، آن ستون‌هایی از V اولیه (قبل از حذف سطرها) را ۰ می‌کنیم. سپس، ستون‌های فوق را از V حذف کرده، همچنین سطرهای تمام ۰ V را نیز حذف کرده و ستون‌های متناظر با این سطرها را نیز از S حذف می‌کنیم. در نهایت مانند دور قبل با استفاده از مساله MILP زیر، تعدادی از ستون‌های V را نیز ۰ کرده و به این ترتیب به پاسخ خوبی برای این سوال می‌رسیم

![l1_problem_lp](https://github.com/AhmadRHM/Optimizer2021_Round5/blob/main/images/rows_MILP.png)   
</div>

## ⛓️ محدودیت‌ها <a name = "limitations"></a>
  <div dir = "rtl">
  با توجه به این که حل MILP کند است، قسمت‌هایی از راه حل فوق که از MILP استفاده می‌کنند برای ورودی‌های با ابعاد بزرگ، مناسب نیست و اجرای آن بسیار طول می‌کشد. به همین دلیل اجرای کامل روش فوق نیازمند به خیلی بزرگ نبودن داده‌های ورودی است. برای داده‌های ورودی بزرگ، می‌توان از همان خروجی بخش اول استفاده کرد که جواب نسبتا خوبی به ما می‌دهد. درواقع در روش فوق در قسمت اول یک جواب پایه‌ی نسبتا خوب با استفاده از ایده‌های دور دوم پیدا می‌کنیم و سپس با استفاده از MILPها در صورت خیلی بزرگ نبودن مساله آن جواب را بهبود می‌بخشیم.
  </div>
  
## 🚀 ایده‌های گسترش <a name = "future_scope"></a>
<div dir = "rtl">
می‌توان یک بار قبل از اعمال MILPای که ستون‌های V را صفر می‌کند، یک بار MILPای که تعدادی از سطرهای V را ۰ می‌کند را اجرا کرد تا سایز مساله ورودی به MILP صفر کننده ستون کمتر شود.
</div>

## 🏁 روند اجرا <a name = "getting_started"></a>
<div dir = "rtl">
کافیست کد را در کنار فایل ورودی قرار داده، نام فایل ورودی را در کد در خط دوم سلول دوم به نام فایل ورودی مورد نظر تغییر داده؛ مقادیر size_of_v_r, size_of_v_c  را نیز که سایز ماتریس V خروجی است و size_of_s_r را که تعداد سطرهای ماتریس S است، در خطوط اول تا سوم از سلول سوم، با توجه به ابعاد داده‌ی ورودی به‌روزرسانی کنید. در نهایت سلول‌ها را به ترتیب اجرا کنید. پس از اتمام اجرا، خروجی مورد نظر در فایل output.txt در کنار کد ذخیره خواهد شد. بالای سلول‌های کد توضیح داده شده که در آن سلول قرار است چه کاری انجام شود. همچنین بعد از اجرای هر یک از سه مرحله روش فوق، نتیجه ذخیره می‌شود. بنابراین برای مثال اگر اندازه داده‌های ورودی بسیار بزرگ بود، با اجرای سلول‌های تا قبل از MILP اول نیز، پاسخ خوبی در کنار کد ذخیره می‌شود.
</div>

### پیش‌نیازها
<div dir = "rtl">
  از آنجا که در کد از زبان جولیا استفاده شده‌است، نیاز است این زبان نصب شود. همچنین بسته‌هایی که در سلول اول کد استفاده شده‌اند نیز باید نصب شود. برای نصب جولیا و بسته‌های مورد نظر می‌توانید به وب‌سایت جولیا مراجعه کنید.
  </div>

### نصب

## ⛏️ وابستگی‌ها <a name = "tech_stack"></a>
<div dir = "rtl">
همانطور که در بخش پیشنیازها گفته شد، باید زبان Julia نصب شود.
  همچنین پکیج‌های زیر نیز باید در Julia نصب شوند:
</div>
  
  
* JuMP
* ECOS
* GLPK
* MAT
* Cbc
* SparseArrays
* DelimitedFiles 
* LinearAlgebra
* MathOptInterface

## ✍️ نویسندگان <a name = "authors"></a>
<div dir = "rtl">
 احمد رحیمی و دیبا هاشمی
</div>
<!---## 🎉 قدردانی <a name = "acknowledgments"></a>
تشکر از هر کسی که به نحوی در گسترش این کد به شما کمک کرده است
--->
